Getting a config

The first thing we always do is check the url for an existing config.
If there is a config there, we check to see if it is valid.
If it is valid, then we are done.
If it is not valid, then we remove it from the url and go to the next step.


In Javascript, I need to get a config object using an async function.
When I try to get the config, I want to check the URL first if there is a valid config there encoded as a JSON object represented with btoa that is under a specific query parameter.
If there is one there, and it is valid, then the function will return the deserialized object.
If there is one and it is invalid, then remove that query param from the URL and proceed to the next stage.
If there is no config in the URL, then proceed to the next stage: using DOM elements to get the config from the user.
DOM elements will be created programmatically, have eventListeners attached to them, and appended to the DOM in the document body, where it will be the only elements in the DOM.
When the user clicks a submit button, the values for the inputs will be read and made into a config object that is checked using the same validation for the URL.
If the config from the url is valid, the function will return the config object.
If the config is not valid, then the invalid inputs will display what is wrong with them.
The user can then submit again, and the same check is performed.
There is a checkbox the user can click to store the config they make into the URL as a query parameter.
When the user successfully submits a config, the DOM elements are removed from the DOM.

These are type definitions for the Config object under the Config type.
```typescript
export type PartName = 'bass' | 'drum' | 'keys' | 'lead'

export type DuplexMidiConfig = {
    input: string
    output: string
}

export type OneIndexedMidiChannel = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16

export type SimplexMidiConfig = {
    output: string
    channel: OneIndexedMidiChannel
}

export enum TransporterType {
    Dom,
    Midi,
}

export type DomTransporterConfig = {
    type: TransporterType.Dom
}

export type MidiTransporterConfig = {
    type: TransporterType.Midi
    midi: DuplexMidiConfig
}

export type TransporterConfig = DomTransporterConfig | MidiTransporterConfig

export enum ControllerType {
    Dom,
    Midi,
}

export type DomControllerConfig = {
    type: ControllerType.Dom
}

export type MidiControllerConfig = {
    type: ControllerType.Midi
    midi: DuplexMidiConfig
}

export type ControllerConfig = DomControllerConfig | MidiControllerConfig

export enum SynthesizerType {
    Dom,
    Midi,
}

export type DomSynthesizerConfig = {
    type: SynthesizerType.Dom
}

export type MidiSynthesizerConfig = {
    type: SynthesizerType.Midi
    midi: SimplexMidiConfig
}

export type SynthesizerConfig = DomSynthesizerConfig | MidiSynthesizerConfig

export type PartConfig = {
    controller: ControllerConfig
    synthesizer: SynthesizerConfig
}

export type PartsConfig = {
    [key in PartName]: PartConfig
}

export type Config = {
    transporter: TransporterConfig
    parts: PartsConfig
}
```
The project I am working on now does not use typescript, but I wanted to give you an idea of how the config would be look.

When choosing a MIDI port, it should be a select input element with options for the MIDI devices.
There is a button the user can click to refresh the MIDI ports listed.

Import the file './utility.js' which has the following functions:
```javascript
export const midiAccess = await (async () => {
    try {
        return await navigator.requestMIDIAccess({ sysex: true })
    } catch {
        return null
    }
})()

//-----------------------------------------------------------------------------

export function dm(tag, attributes = {}, ...children) {
    const element = document.createElement(tag)

    for (const [key, value] of Object.entries(attributes)) {
        element.setAttribute(key, value)
    }

    for (const child of children) {
        if (typeof child === 'string') {
            element.appendChild(document.createTextNode(child))
        } else if (child) {
            element.appendChild(child)
        }
    }

    return element
}
```
Use dm to create all of your elements and midiAccess to get the MIDI ports.

Use an object oriented approach to model the transporter portion, the parts, the simplex midi and duplex midi portions of the config.

In your response, write vanilla javascript code that exports default a function called getConfig that takes no arguments and returns a Promise<Config> that resolves with the config object.

--------------------------------------------------------------------------------------------------------

Write an HTML file that is a MIDI sequencer app.
When the page is opened, the URL is checked to see if it contains a config.
If it does, then the config is used to set up the sequencer.
If it does not, then the user is prompted to enter a config.
The config says what MIDI device names and channels to use for the synthesizers.
There are 4 different parts: bass, drum, keys, and lead.
After the config loads, there are media transport controls for previous, play, pause, stop, and next.
The previous and next buttons are disabled if there is no previous or next chart to play.
Each chart is a script that is loaded and sends MIDI messages.
The play button starts the chart.
The pause button pauses the chart.
The stop button stops the chart.
The previous button stops the chart goes to the previous chart.
The next button stops the chart goes to the next chart.
When a chart is loaded, the source code is displayed in a textarea.
The user can edit the source code for the chart and click a button to save the changes.
When the user saves the changes, the chart is reloaded with the new source code.
Include 3 charts: one that plays a middle c on the lead synth for 4 beats, one that plays a c major scale on the bass synth, and a simple blues song that uses all 4 parts.
Write a single HTML file that contains all of the styles and code for the app.

--------------------------------------------------------------------------------------------------------

New config idea:
Transporter:
    -Is MIDI checkbox
    -MIDI input/output selects
Band:
    -Checkbox for if there should be a textarea for the source code of the chart
    -4 parts: bass, drum, keys, lead
    -Each part has a controller and a synthesizer
        -Controller:
            -Is MIDI checkbox
            -MIDI input/output selects
        -Synthesizer:
            -Checkbox for if it is over MIDI or not
            -MIDI output select
            -MIDI channel input
Misc:
    -Checkbox to store the config in the URL

{
    showSourceCode: false,
    transporter: {
        isMidi: false,
    },
    band: {
        bass: {
            controller: {
                isMidi: false,
            },
            synthesizer: {
                isMidi: false,
            },
        },
        drum: {
            controller: {
                isMidi: false,
            },
            synthesizer: {
                isMidi: false,
            },
        },
        keys: {
            controller: {
                isMidi: false,
            },
            synthesizer: {
                isMidi: false,
            },
        },
        lead: {
            controller: {
                isMidi: false,
            },
            synthesizer: {
                isMidi: false,
            },
        },
    },
}

{
    showSourceCode: true,
    transporter: {
        isMidi: true,
        ports: {
            input: '%%TRANSPORTER_MIDI_INPUT%%',
            output: '%TRANSPORTER_%MIDI_OUTPUT%%',
        },
    },
    band: {
        bass: {
            controller: {
                isMidi: true,
                ports: {
                    input: '%%BASS_CONTROLLER_MIDI_INPUT%%',
                    output: '%%BASS_CONTROLLER_MIDI_OUTPUT%%',
                },
            },
            synthesizer: {
                isMidi: true,
                output: {
                    port: '%%BASS_SYNTHESIZER_MIDI_OUTPUT%%',
                    channel: '%%BASS_SYNTHESIZER_MIDI_CHANNEL%%',
                },
            },
        },
        drum: {
            controller: {
                isMidi: true,
                ports: {
                    input: '%%DRUM_CONTROLLER_MIDI_INPUT%%',
                    output: '%%DRUM_CONTROLLER_MIDI_OUTPUT%%',
                },
            },
            synthesizer: {
                isMidi: true,
                output: {
                    port: '%%DRUM_SYNTHESIZER_MIDI_OUTPUT%%',
                    channel: '%%DRUM_SYNTHESIZER_MIDI_CHANNEL%%',
                },
            },
        },
        keys: {
            controller: {
                isMidi: true,
                ports: {
                    input: '%%KEYS_CONTROLLER_MIDI_INPUT%%',
                    output: '%%KEYS_CONTROLLER_MIDI_OUTPUT%%',
                },
            },
            synthesizer: {
                isMidi: true,
                output: {
                    port: '%%KEYS_SYNTHESIZER_MIDI_OUTPUT%%',
                    channel: '%%KEYS_SYNTHESIZER_MIDI_CHANNEL%%',
                },
            },
        },
        lead: {
            controller: {
                isMidi: true,
                ports: {
                    input: '%%LEAD_CONTROLLER_MIDI_INPUT%%',
                    output: '%%LEAD_CONTROLLER_MIDI_OUTPUT%%',
                },
            },
            synthesizer: {
                isMidi: true,
                output: {
                    port: '%%LEAD_SYNTHESIZER_MIDI_OUTPUT%%',
                    channel: '%%LEAD_SYNTHESIZER_MIDI_CHANNEL%%',
                },
            },
        },
    },
}

--------------------------------------------------------------------------------------------------------

Things to implement in new build:
-Editable source code for the charts
-MIDI transporters and controllers
-Recording performances to a MIDI file: "%%CHART_NAME%%-%%TIMESTAMP%%.mid"
-Controllers having richer control creation

--------------------------------------------------------------------------------------------------------

Evolution of the project:

2018-2019:
-Came up with idea for synth show
-Discovered Algorithmic Composition
-Didn't put them together yet
-Built synth case with MIDI file sequencer

2019-2022:
-Using 4 different raspberry pis all talking to each other over ethernet
-Each pi is a different part of the band
-They have to talk to each other to coordinate
-They use their GPIO pins for MIDI 5-pin DIN communication
-Was going to write it with Python

2022-2023:
-Wanted to make a way of running the show on a single computer
-Discovered Web MIDI API
-Learned web development
-Started building the project in vanilla javascript
-Wanted to be able to run with Web Audio using Tone.js
-Wanted to be able to connect to transporter and controller over WebRTC
-Although these ^ wouldn't be relevant for the final project, I just thought it would be really cool to do

2024-2025:
-Broke up with all packages, dependencies, and frameworks
-Rebuilt the project in vanilla javascript
-Just wanted to do it

--------------------------------------------------------------------------------------------------------

Refactor Ideas:
-Configs get stuff from the portions they config

--------------------------------------------------------------------------------------------------------

Every object in has the following:
-A way to test its portion of the config
    -This either passes and returns null or fails and throws an error
    -Any values that are valid are stored in the object
-A way to get the DOM element(s) for the portion of the config
    -The DOM element created is returned
-A way to get the config object for the portion of the config
    -The config object is returned
    -This should not be able to fail, as any invalid values should have been caught by the test